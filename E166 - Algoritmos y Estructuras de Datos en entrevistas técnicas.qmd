---
title: "Algoritmos y Estructuras de Datos en Entrevistas T√©cnicas"
subtitle: "Gu√≠a pr√°ctica para prepararse con Python"
author: "en_coders - Claude guiado y corregido por Rodo"
date: today
format:
  html:
    theme: darkly
    toc: true
    toc-depth: 3
    code-fold: true
    code-summary: "Ver c√≥digo"
    number-sections: true
    smooth-scroll: true
lang: es
---

# Introducci√≥n

En esta gu√≠a aprenderemos las estructuras de datos y algoritmos m√°s importantes para afrontar entrevistas t√©cnicas. Nos enfocamos en Python y en los patrones que los entrevistadores esperan que domines.

------------------------------------------------------------------------

# Estructuras de Datos Fundamentales

## Arrays (Listas en Python)

### Definici√≥n

Un array es una estructura de datos que almacena elementos del mismo tipo en posiciones de memoria contiguas. En Python, las listas son la implementaci√≥n de arrays din√°micos que pueden cambiar de tama√±o.

**Caracter√≠sticas:**

-   Acceso en O(1) por √≠ndice

-   Inserci√≥n/eliminaci√≥n al final en O(1)

-   Inserci√≥n/eliminaci√≥n no al final en O(n)

-   B√∫squeda lineal en O(n)

### Ejemplo

```{python}
# Crear y manipular una lista
numeros = [1, 2, 3, 4, 5]

# Acceso por √≠ndice
print(f"Primer elemento: {numeros[0]}")  # O(1)

# Agregar elemento al final
numeros.append(6)  # O(1)

# Insertar en posici√≥n espec√≠fica
numeros.insert(2, 10)  # O(n)

# Eliminar elemento
numeros.pop()  # O(1) si es el √∫ltimo

# Iterar sobre la lista
for num in numeros: # O(n)
    print(num)
```

------------------------------------------------------------------------

## Strings

### Definici√≥n

Un string es una secuencia de caracteres inmutable en Python. Se puede trabajar con substrings, b√∫squedas y manipulaciones.

**Caracter√≠sticas:**

-   Acceso por √≠ndice en O(1)

-   B√∫squeda de subcadena en O(n\*m)

-   Inmutable en Python (crear nuevo string es O(n))

-   Conversi√≥n a array de caracteres con list()

-   Complejidad en espacio en O(n)

### Ejemplo

```{python}
# Trabajar con strings
texto = "entrevista t√©cnica"

# Acceso por √≠ndice
print(f"Primer car√°cter: {texto[0]}")  # O(1)

# Slicing
print(f"Primeras 5 letras: {texto[:5]}")  # O(k) donde k es el tama√±o del slice

# B√∫squeda
print(f"√çndice de 't√©cnica': {texto.find('t√©cnica')}")

# Conversi√≥n a lista
caracteres = list(texto)
print(caracteres)

# Crear string a partir de lista
palabra = ''.join(['p', 'y', 't', 'h', 'o', 'n'])
print(palabra)
```

### Diferencias en complejidad

| M√©todo | Complejidad | Descripci√≥n | Eficiencia |
|:-------------|:-------------|:----------------------------|:-------------|
| `"".join(lista)` | üü¢ **O(n)** | Construye la cadena final de una sola vez, sabiendo su tama√±o total. | ‚úÖ Muy eficiente |
| `list.append()` + `"".join()` | üü¢ **O(n)** | Usa una lista temporal (append es O(1)) y luego una sola concatenaci√≥n con join. | ‚úÖ Muy eficiente |
| `+=` en bucle | üî¥ **O(n¬≤)** | Cada concatenaci√≥n crea una nueva cadena y copia todo lo anterior. | ‚ùå Muy ineficiente |

```{python}
import time

palabras = ["python"] * 100_000

# 1Ô∏è‚É£ join directo
start = time.time()
"".join(palabras)
print("join directo:", round(time.time() - start, 4), "s")

# 2Ô∏è‚É£ append + join
start = time.time()
temp = []
for p in palabras:
    temp.append(p)
"".join(temp)
print("append + join:", round(time.time() - start, 4), "s")

# 3Ô∏è‚É£ concatenaci√≥n con +=
start = time.time()
s = ""
for p in palabras:
    s += p
print("+= :", round(time.time() - start, 4), "s")


```

------------------------------------------------------------------------

## Hash Tables (Diccionarios en Python)

### Definici√≥n

Una hash table es una estructura que mapea claves a valores usando una funci√≥n hash. En Python, los diccionarios son hash tables que permiten b√∫squeda, inserci√≥n y eliminaci√≥n en O(1) promedio.

**Caracter√≠sticas:**

-   Inserci√≥n en O(1) promedio

-   B√∫squeda en O(1) promedio

-   Eliminaci√≥n en O(1) promedio

-   Uso de memoria proporcional a la cantidad de elementos

-   Complejidad en espacio en O(n)

### Ejemplo

```{python}
# Crear y manipular diccionarios
estudiante = {
    "nombre": "Ana",
    "edad": 25,
    "carrera": "Ingenier√≠a"
}

# Acceso a valores
print(f"Nombre: {estudiante['nombre']}")  # O(1)

# Agregar nuevo campo
estudiante["semestre"] = 5  # O(1)

# Verificar si existe una clave
if "edad" in estudiante:
    print(f"La edad es: {estudiante['edad']}")

# Iterar sobre diccionario
for clave, valor in estudiante.items():
    print(f"{clave}: {valor}")

# Usar diccionario para contar frecuencias
palabras = ["python", "java", "python", "c++", "java", "python"]
frecuencia = {}
for palabra in palabras:
    frecuencia[palabra] = frecuencia.get(palabra, 0) + 1
print(f"Frecuencias: {frecuencia}")
```

------------------------------------------------------------------------

## Stacks (Pilas)

### Definici√≥n

Un stack es una estructura de datos LIFO (Last In, First Out). El √∫ltimo elemento insertado es el primero en salir. Operaciones principales: push (agregar) y pop (remover).

**Caracter√≠sticas:**

-   Push en O(1)

-   Pop en O(1)

-   Peek (ver tope) en O(1)

-   Complejidad en espacio en O(n)

### Ejemplo

```{python}
# Implementar un stack
class Stack:
    def __init__(self):
        self.items = []
    
    def push(self, item):
        """Agregar elemento al tope"""
        self.items.append(item)  # O(1)
    
    def pop(self):
        """Remover y retornar elemento del tope"""
        if not self.is_empty():
            return self.items.pop()  # O(1)
        return None
    
    def peek(self):
        """Ver el elemento del tope sin remover"""
        if not self.is_empty():
            return self.items[-1]  # O(1)
        return None
    
    def is_empty(self):
        return len(self.items) == 0
    
    def size(self):
        return len(self.items)

# Usar el stack
stack = Stack()
stack.push(1)
stack.push(2)
stack.push(3)

print(f"Tope: {stack.peek()}")  # 3
print(f"Removido: {stack.pop()}")  # 3
print(f"Tama√±o: {stack.size()}")  # 2
```

Python no tiene una estructura `Stack` nativa en el m√≥dulo est√°ndar. Pero podemos usar listas o importar deque.

1.  **Usar `list`** (m√°s simple):

```{python}
stack = []
item = 7
stack.append(item)      # push
stack[-1]               # peek
stack.pop()             # pop
```

2.  **Usar `collections.deque`** (m√°s eficiente):

```{python}
from collections import deque
stack = deque()
item = 7
stack.append(item)      # push
stack[-1]               # peek
stack.pop()             # pop
```

La clase que mostramos arriba es m√°s did√°ctica para entender el concepto, pero en la pr√°ctica solo necesitas `list` o `deque`.

------------------------------------------------------------------------

## Queues (Colas)

### Definici√≥n

Una queue es una estructura FIFO (First In, First Out). El primer elemento insertado es el primero en salir. Operaciones principales: enqueue (agregar al final) y dequeue (remover del inicio).

**Caracter√≠sticas:**

-   Enqueue en O(1)

-   Dequeue en O(1)

-   Peek en O(1)

-   Complejidad en espacio en O(n)

### Ejemplo

```{python}
from collections import deque

# Usar deque para implementar una queue eficiente
cola = deque()

# Enqueue - agregar al final
cola.append(1)  # O(1)
cola.append(2)
cola.append(3)

# Dequeue - remover del inicio
primer = cola.popleft()  # O(1)
print(f"Primer elemento: {primer}")

# Peek
print(f"Siguiente elemento: {cola[0]}")

# Verificar si est√° vac√≠a
if cola:
    print(f"La cola tiene {len(cola)} elementos")

# Iterar
print("Elementos en la cola:")
for elemento in cola:
    print(elemento)
```

------------------------------------------------------------------------

## Linked Lists (Listas Enlazadas)

### Definici√≥n

Una linked list es una estructura donde cada nodo contiene datos y una referencia al siguiente nodo. A diferencia de arrays, no usa memoria contigua.

**Caracter√≠sticas:**

-   Inserci√≥n al inicio en O(1)

-   Inserci√≥n en O(n) en posici√≥n espec√≠fica

-   B√∫squeda en O(n)

-   Eliminaci√≥n en O(n)

-   Complejidad en espacio en O(n)

### Ejemplo

```{python}
# Definir un nodo
class Node:
    def __init__(self, valor):
        self.valor = valor
        self.siguiente = None

# Definir una linked list
class LinkedList:
    def __init__(self):
        self.cabeza = None
    
    def insertar_inicio(self, valor):
        """Insertar al inicio en O(1)"""
        nuevo_nodo = Node(valor)
        nuevo_nodo.siguiente = self.cabeza
        self.cabeza = nuevo_nodo
    
    def insertar_final(self, valor):
        """Insertar al final en O(n)"""
        nuevo_nodo = Node(valor)
        if not self.cabeza:
            self.cabeza = nuevo_nodo
            return
        
        actual = self.cabeza
        while actual.siguiente:
            actual = actual.siguiente
        actual.siguiente = nuevo_nodo
    
    def buscar(self, valor):
        """Buscar un valor en O(n)"""
        actual = self.cabeza
        while actual:
            if actual.valor == valor:
                return True
            actual = actual.siguiente
        return False
    
    def imprimir(self):
        """Imprimir la lista"""
        actual = self.cabeza
        while actual:
            print(actual.valor, end=" -> ")
            actual = actual.siguiente
        print("None")

# Usar la linked list
lista = LinkedList()
lista.insertar_inicio(1)
lista.insertar_final(2)
lista.insertar_final(3)
lista.imprimir()
print(f"¬øContiene 2? {lista.buscar(2)}")
```

------------------------------------------------------------------------

## Trees (√Årboles)

### Definici√≥n

Un √°rbol es una estructura jer√°rquica donde cada nodo puede tener m√∫ltiples hijos. El nodo superior se llama ra√≠z. Casos especiales: Binary Trees (m√°ximo 2 hijos), Binary Search Trees (BST), etc.

**Caracter√≠sticas:**

-   B√∫squeda en BST en O(log n) promedio

-   Inserci√≥n en BST en O(log n) promedio

-   Complejidad en espacio en O(n).

### Ejemplo

```{python}
# Definir un nodo de √°rbol binario
class TreeNode:
    def __init__(self, valor):
        self.valor = valor
        self.izquierda = None
        self.derecha = None

# Definir un √°rbol binario de b√∫squeda
class BST:
    def __init__(self):
        self.raiz = None
    
    def insertar(self, valor):
        """Insertar un valor en O(log n)"""
        if not self.raiz:
            self.raiz = TreeNode(valor)
        else:
            self._insertar_recursivo(self.raiz, valor)
    
    def _insertar_recursivo(self, nodo, valor):
        if valor < nodo.valor:
            if nodo.izquierda is None:
                nodo.izquierda = TreeNode(valor)
            else:
                self._insertar_recursivo(nodo.izquierda, valor)
        else:
            if nodo.derecha is None:
                nodo.derecha = TreeNode(valor)
            else:
                self._insertar_recursivo(nodo.derecha, valor)
    
    def buscar(self, valor):
        """Buscar un valor en O(log n)"""
        return self._buscar_recursivo(self.raiz, valor)
    
    def _buscar_recursivo(self, nodo, valor):
        if nodo is None:
            return False
        
        if valor == nodo.valor:
            return True
        elif valor < nodo.valor:
            return self._buscar_recursivo(nodo.izquierda, valor)
        else:
            return self._buscar_recursivo(nodo.derecha, valor)

# Usar el BST
arbol = BST()
for val in [5, 3, 7, 1, 9]:
    arbol.insertar(val)

print(f"¬øContiene 7? {arbol.buscar(7)}")
print(f"¬øContiene 10? {arbol.buscar(10)}")
```

------------------------------------------------------------------------

## Heaps (Mont√≠culos)

### Definici√≥n

Un heap es un √°rbol binario completo que satisface la propiedad heap. En un min-heap, cada padre es menor que sus hijos. En un max-heap, cada padre es mayor que sus hijos.

**Caracter√≠sticas:**

-   Inserci√≥n en O(log n)

-   Extracci√≥n del m√≠nimo/m√°ximo en O(log n)

-   Ver m√≠nimo/m√°ximo en O(1)

-   Espacio en O(n)

### Ejemplo

```{python}
import heapq

# Usar heapq para min-heap
numeros = [5, 2, 8, 1, 9]
heap = numeros.copy()
heapq.heapify(heap)  # Crear heap en O(n)

print(f"Heap: {heap}")

# Insertar elemento
heapq.heappush(heap, 3)  # O(log n)

# Extraer m√≠nimo
minimo = heapq.heappop(heap)  # O(log n)
print(f"M√≠nimo extra√≠do: {minimo}")

# Ver m√≠nimo sin extraer
print(f"Pr√≥ximo m√≠nimo: {heap[0]}")  # O(1)

# Para max-heap, insertar negativos
max_heap = [-x for x in numeros]
heapq.heapify(max_heap)
maximo = -heapq.heappop(max_heap)
print(f"M√°ximo: {maximo}")
```

------------------------------------------------------------------------

## Graphs (Grafos)

### Definici√≥n

Un grafo es una estructura compuesta por nodos (v√©rtices) y aristas que conectan pares de nodos. Pueden ser dirigidos o no dirigidos, ponderados o sin peso.

**Caracter√≠sticas:**

-   Representaci√≥n con matriz de adyacencia: O(V¬≤) espacio, O(1) b√∫squeda de si existe o no una arista (i,j)

-   Representaci√≥n con lista de adyacencia: O(V+E) espacio, O(1) promedio b√∫squeda de vecinos

-   Traversal (DFS/BFS): O(V+E) en recorrer todo el grafo

### Ejemplo

```{python}
# Representar un grafo con lista de adyacencia
class Grafo:
    def __init__(self):
        self.adyacencia = {}
    
    def agregar_nodo(self, nodo):
        if nodo not in self.adyacencia:
            self.adyacencia[nodo] = []
    
    def agregar_arista(self, u, v):
        """Agregar arista dirigida de u a v"""
        self.agregar_nodo(u)
        self.agregar_nodo(v)
        self.adyacencia[u].append(v)
    
    def obtener_vecinos(self, nodo):
        return self.adyacencia.get(nodo, [])

# Usar el grafo
grafo = Grafo()
grafo.agregar_arista(1, 2)
grafo.agregar_arista(1, 3)
grafo.agregar_arista(2, 4)
grafo.agregar_arista(3, 4)

print(f"Vecinos de 1: {grafo.obtener_vecinos(1)}")
print(f"Vecinos de 2: {grafo.obtener_vecinos(2)}")
```

------------------------------------------------------------------------

# Algoritmos y Patrones Importantes

## Pattern: Two Pointers

### Definici√≥n

El patr√≥n Two Pointers utiliza dos punteros que se mueven a trav√©s de una estructura de datos. Es especialmente √∫til en arrays y strings para problemas de b√∫squeda, validaci√≥n y transformaci√≥n.

**Cu√°ndo usarlo:**

-   Arrays/strings ordenados

-   Encontrar pares con suma objetivo

-   Validar pal√≠ndromos

-   Remover duplicados

### Ejemplo LeetCode: Two Sum II (Input Array Is Sorted)

**Problema:** Dado un array de n√∫meros ya ordenado, encuentra dos n√∫meros que sumen a un objetivo espec√≠fico.

```{python}
def two_sum_sorted(numbers, target):
    """
    Encontrar dos n√∫meros que sumen al objetivo en un array ordenado.
    
    Complejidad: O(n) tiempo, O(1) espacio
    """
    izquierda = 0
    derecha = len(numbers) - 1
    
    while izquierda < derecha:
        suma = numbers[izquierda] + numbers[derecha]
        
        if suma == target:
            return [izquierda + 1, derecha + 1]  # 1-indexed
        elif suma < target:
            izquierda += 1
        else:
            derecha -= 1
    
    return []

# Test
resultado = two_sum_sorted([2, 7, 11, 15], 9)
print(f"√çndices: {resultado}")  # [1, 2]
```

------------------------------------------------------------------------

## Pattern: Sliding Window

### Definici√≥n

El patr√≥n Sliding Window mantiene una ventana de tama√±o fijo o variable que se desliza a trav√©s de una estructura de datos. Reduce problemas de b√∫squeda a trav√©s de subarrays de O(n¬≤) a O(n).

**Cu√°ndo usarlo:**

-   Subarrays con suma m√°xima/m√≠nima

-   Subcadenas con propiedades espec√≠ficas

-   Problemas con "contiguous" en el enunciado

### Ejemplo LeetCode: Longest Substring Without Repeating Characters

**Problema:** Encuentra la subcadena m√°s larga sin caracteres repetidos.

```{python}
def longest_substring_without_repeating(s):
    """
    Encontrar la subcadena m√°s larga sin caracteres repetidos.
    
    Complejidad: O(n) tiempo, O(min(n, m)) espacio donde m es el tama√±o del charset
    """
    char_index = {}
    izquierda = 0
    max_len = 0
    
    for derecha in range(len(s)):
        char = s[derecha]
        
        # Si el car√°cter ya existe y est√° dentro de la ventana
        if char in char_index and char_index[char] >= izquierda:
            izquierda = char_index[char] + 1
        
        # Actualizar el √≠ndice del car√°cter
        char_index[char] = derecha
        
        # Actualizar la longitud m√°xima
        max_len = max(max_len, derecha - izquierda + 1)
    
    return max_len

# Test
resultado = longest_substring_without_repeating("abcabcbb")
print(f"Longitud m√°xima: {resultado}")  # 3 (abc)
```

------------------------------------------------------------------------

## Pattern: Depth-First Search (DFS)

### Definici√≥n

DFS es un algoritmo de traversal que explora todo lo posible a lo largo de cada rama antes de retroceder. Se implementa t√≠picamente con recursi√≥n o un stack.

**Complejidad:** O(V+E) para grafos, O(n) para √°rboles

**Cu√°ndo usarlo:**

-   Exploraci√≥n exhaustiva de nodos

-   Detecci√≥n de ciclos

-   Topological sorting

-   Path finding

### Ejemplo LeetCode: Number of Islands

**Problema:** Dado una matriz de '1's (tierra) y '0's (agua), cuenta el n√∫mero de islas.

```{python}
def num_islands(grid):
    """
    Contar el n√∫mero de islas usando DFS.
    
    Complejidad: O(m*n) tiempo, O(m*n) espacio en peor caso (recursi√≥n)
    """
    if not grid:
        return 0
    
    rows, cols = len(grid), len(grid[0])
    visited = set()
    count = 0
    
    def dfs(r, c):
        # Validar l√≠mites y si ya fue visitado
        if r < 0 or r >= rows or c < 0 or c >= cols:
            return
        if (r, c) in visited or grid[r][c] == '0':
            return
        
        visited.add((r, c))
        
        # Explorar 4 direcciones
        dfs(r + 1, c)  # abajo
        dfs(r - 1, c)  # arriba
        dfs(r, c + 1)  # derecha
        dfs(r, c - 1)  # izquierda
    
    for r in range(rows):
        for c in range(cols):
            if grid[r][c] == '1' and (r, c) not in visited:
                dfs(r, c)
                count += 1
    
    return count

# Test
grid = [
    ["1","1","1","1","0"],
    ["1","1","0","1","0"],
    ["1","1","0","0","0"],
    ["0","0","0","0","0"]
]
resultado = num_islands(grid)
print(f"N√∫mero de islas: {resultado}")  # 1
```

------------------------------------------------------------------------

## Pattern: Breadth-First Search (BFS)

### Definici√≥n

BFS es un algoritmo de traversal que explora nodos nivel por nivel. Se implementa t√≠picamente con una queue.

**Complejidad:** O(V+E) para grafos, O(n) para √°rboles

**Cu√°ndo usarlo:**

-   Camino m√°s corto en grafos sin pesos

-   Exploraci√≥n por niveles

-   Problemas de distancia

-   Flood fill

### Ejemplo LeetCode: Binary Tree Level Order Traversal

**Problema:** Realiza un traversal por niveles de un √°rbol binario.

```{python}
from collections import deque

class TreeNode:
    def __init__(self, valor):
        self.valor = valor
        self.izquierda = None
        self.derecha = None

def level_order(raiz):
    """
    Traversal por niveles usando BFS.
    
    Complejidad: O(n) tiempo, O(w) espacio donde w es el ancho m√°ximo
    """
    if not raiz:
        return []
    
    resultado = []
    cola = deque([raiz])
    
    while cola:
        nivel_size = len(cola)
        nivel_actual = []
        
        # Procesar todos los nodos del nivel actual
        for _ in range(nivel_size):
            nodo = cola.popleft()
            nivel_actual.append(nodo.valor)
            
            if nodo.izquierda:
                cola.append(nodo.izquierda)
            if nodo.derecha:
                cola.append(nodo.derecha)
        
        resultado.append(nivel_actual)
    
    return resultado

# Test
raiz = TreeNode(1)
raiz.izquierda = TreeNode(2)
raiz.derecha = TreeNode(3)
raiz.izquierda.izquierda = TreeNode(4)
raiz.izquierda.derecha = TreeNode(5)

resultado = level_order(raiz)
print(f"Traversal por niveles: {resultado}")  # [[1], [2, 3], [4, 5]]
```

------------------------------------------------------------------------

# C√≥mo Prepararse para Entrevistas T√©cnicas

## Metodolog√≠a: Problem Solving

### 1. Escucha (Listen)

-   Lee el problema cuidadosamente

-   Pregunta por clarificaciones

-   Confirma los supuestos (¬øordenado? ¬øduplicados? ¬ønegativos?)

-   Pregunta por los rangos de entrada

### 2. Dibuja un Ejemplo (Draw)

-   Usa un ejemplo no trivial

-   Dibuja o visualiza el problema

-   Identifica patrones

-   Entiende qu√© transformaci√≥n necesitas

### 3. Fuerza Bruta (Brute Force)

-   Prop√≥n una soluci√≥n inicial incluso si es ineficiente

-   Explica tu l√≥gica claramente

-   No codes todav√≠a, solo planifica

### 4. Optimiza (Optimize)

#### BUD - Bottlenecks, Unnecessary work, Duplicated work

**Bottlenecks:** ¬øD√≥nde pasa la mayor√≠a del tiempo?

-   B√∫squedas innecesarias

-   Loops anidados

-   Conversiones de estructura

**Trabajo Innecesario:** ¬øHacemos algo que no necesitamos?

-   Procesamos datos que no usamos

-   Comparamos elementos m√∫ltiples veces

-   Exploramos caminos inv√°lidos

**Trabajo Duplicado:** ¬øCalculamos lo mismo varias veces?

-   Use memoization

-   Use dynamic programming

-   Cache resultados

#### Space-Time Tradeoff

-   Podemos usar espacio adicional para mejorar tiempo

-   Ejemplos: Hash tables para O(1) lookup, cache para evitar rec√°lculos

### 5. Explica tu Algoritmo (Walk Through)

-   Camina a trav√©s del algoritmo con el ejemplo

-   Explica cada paso

-   Verifica que es correcto conceptualmente

### 6. Implementa (Code)

#### Expectativas

**Correctitud:** El c√≥digo debe resolver el problema correctamente

**Legibilidad:**

-   Nombres descriptivos

-   C√≥digo modular

-   Comentarios donde sea necesario

**Mantenibilidad:**

-   Evita duplication

-   Funciones reutilizables

-   Manejo de edge cases

**Performance:**

-   Complejidad √≥ptima

-   Sin optimizaciones prematuras

#### Estructura

-   Modulariza desde arriba hacia abajo

-   Asume que tienes funciones simples disponibles

-   Implementa funciones helper al final si es necesario

### 7. Verifica (Verify)

#### Conceptual Walkthrough

-   Revisa la l√≥gica del c√≥digo

-   ¬øTiene sentido?

-   ¬øCubre todos los casos?

#### Hot Spots

Revisa l√≠neas de alto riesgo:

-   Operaciones matem√°ticas

-   Movimiento de √≠ndices

-   Par√°metros en llamadas recursivas

-   Base cases

-   Condiciones l√≠mite

#### Test Cases

**Ejemplo diferente:** Prueba con datos distintos a los que usaste antes

**Ejemplo peque√±o:** Prueba con el m√≠nimo input v√°lido

**Edge Cases Aburridos:**

-   Valores nulos/vac√≠os

-   Un solo elemento

-   Valores duplicados

-   Valores ordenados/sin ordenar

**Edge Cases Interesantes:**

-   N√∫meros negativos

-   L√≠mites de rangos

-   Casos de error

**No:** No pruebes un ejemplo complicado a mano

### 8. Comunicaci√≥n

-   Maneja el problema, no solo resuelve

-   Muestra tu proceso de pensamiento

-   Haz preguntas

-   Prop√≥n una soluci√≥n inicial pero tambi√©n piensa en problemas

-   Habla mientras codeas

-   Usa ejemplos para explicar

-   S√© honesto con errores

-   Admite si ya has visto el problema

-   Escucha a tu entrevistador

-   Captura el valor de las pistas

-   Sigue el camino que tu entrevistador sugiere

------------------------------------------------------------------------

## Estructuras de Datos: Cu√°ndo Usarlas

### Arrays / Listas

**Ventajas:**

-   Acceso r√°pido por √≠ndice O(1)

-   Iteraci√≥n eficiente

-   Cache-friendly en memoria

**Cu√°ndo usar:**

-   Necesitas acceso por posici√≥n

-   Trabajas con datos secuenciales

-   El tama√±o est√° predefinido o cambia poco

**Evitar:**

-   Inserciones/eliminaciones frecuentes en medio

### Hash Tables / Diccionarios

**Ventajas:**

-   B√∫squeda/inserci√≥n/eliminaci√≥n O(1)

-   Flexible con tipos de claves

-   Sin necesidad de ordenamiento

**Cu√°ndo usar:**

-   Contador de frecuencias

-   Mapa de relaciones

-   Cache/memoization

-   Validaci√≥n de pertenencia

**Evitar:**

-   Cuando necesitas orden

-   Cuando necesitas rango queries

### Strings

**Ventajas:**

-   Optimizados para b√∫squeda de patrones

-   Muchas operaciones built-in

**Cu√°ndo usar:**

-   Manipulaci√≥n de texto

-   B√∫squeda de subcadenas

-   Validaci√≥n de formato

**Evitar:**

-   Concatenaci√≥n repetida (usar list + join)

### Linked Lists

**Ventajas:**

-   Inserci√≥n/eliminaci√≥n al inicio O(1)

-   Sin overhead de redimensionamiento

-   Flexible en tama√±o

**Cu√°ndo usar:**

-   Operaciones frecuentes al inicio/final

-   No necesitas acceso por √≠ndice

**Evitar:**

-   Cuando necesitas acceso aleatorio

-   Cuando la memoria es escasa

### Stacks

**Ventajas:**

-   LIFO intuitivo para ciertos problemas

-   O(1) para todas las operaciones

**Cu√°ndo usar:**

-   Expresiones balanceadas

-   Undo/redo

-   Backtracking

-   Evaluaci√≥n de expresiones

### Queues

**Ventajas:**

-   FIFO para problemas de orden

-   O(1) para operaciones

**Cu√°ndo usar:**

-   BFS

-   Procesamiento por orden de llegada

-   Simulaciones

### Trees

**Ventajas:**

-   BST: b√∫squeda O(log n)

-   Estructura jer√°rquica natural

-   Balanceado: mantiene eficiencia

**Cu√°ndo usar:**

-   Datos jer√°rquicos

-   B√∫squeda r√°pida

-   Ordenamiento din√°mico

### Heaps

**Ventajas:**

-   K elementos m√°s grandes/peque√±os

-   Priority queues

**Cu√°ndo usar:**

-   Top K problems

-   Scheduling

-   Merge sorted lists

### Graphs

**Ventajas:**

-   Modela relaciones complejas

-   DFS/BFS para exploraci√≥n

**Cu√°ndo usar:**

-   Redes sociales

-   Rutas/mapas

-   Dependencias

-   Conectividad

------------------------------------------------------------------------

## Patrones de Soluci√≥n

### Identificar el Patr√≥n

1.  **Two Pointers:** ¬øArrays ordenados? ¬øParejas?
2.  **Sliding Window:** ¬øSubarrays contiguos?
3.  **DFS/BFS:** ¬øNecesitas explorar todos los caminos?
4.  **Dynamic Programming:** ¬øHay subproblemas que se repiten?
5.  **Greedy:** ¬øFunciona elegir la opci√≥n √≥ptima localmente?
6.  **Binary Search:** ¬øArray ordenado? ¬øB√∫squeda eficiente?

### Template Pattern Matching

Para cada problema:

1.  ¬øCu√°l es la entrada?
2.  ¬øCu√°l es la salida?
3.  ¬øCu√°l es la transformaci√≥n?
4.  ¬øQu√© estructura de datos necesito?
5.  ¬øQu√© complejidad es aceptable?

------------------------------------------------------------------------

## Tips Finales para la Entrevista

‚úì **Practica en LeetCode** (Medium level)

‚úì **Entiende, no memorices** - comprende por qu√© funciona

‚úì **Habla en voz alta** - el entrevistador quiere saber tu pensamiento

‚úì **No apures el c√≥digo** - aseg√∫rate de estar listo antes

‚úì **Valida casos l√≠mite** - vac√≠os, negativ, duplicados

‚úì **Refactoriza si ves problemas** - pero sin fixes chapuceros

‚úì **Piensa mientras testeas** - entiende qu√© est√° pasando

------------------------------------------------------------------------

## M√°s Patrones Algoritmos

## Pattern: Dynamic Programming

### Definici√≥n

Dynamic Programming (DP) optimiza problemas que tienen subestructura √≥ptima y subproblemas superpuestos. Evita recalcular los mismos subproblemas.

**Caracter√≠sticas:** - Memoization (top-down): recursi√≥n + cache - Tabulation (bottom-up): iterativo - Reduce complejidad exponencial a polinomial

**Cu√°ndo usarlo:** - El problema pide m√°ximo/m√≠nimo/contar formas - Hay subproblemas que se repiten - Se puede formular recursivamente

### Ejemplo LeetCode: Climbing Stairs

**Problema:** Subes una escalera de n escalones. Cada vez puedes subir 1 o 2 escalones. ¬øDe cu√°ntas formas diferentes puedes subir?

```{python}
def climb_stairs(n):
    """
    Contar formas de subir escalera usando DP.
    
    Complejidad: O(n) tiempo, O(1) espacio
    """
    if n <= 2:
        return n
    
    # dp[i] representa formas de llegar al escal√≥n i
    anterior_dos = 1  # formas de llegar a escal√≥n 1
    anterior_uno = 2  # formas de llegar a escal√≥n 2
    
    for i in range(3, n + 1):
        actual = anterior_uno + anterior_dos
        anterior_dos = anterior_uno
        anterior_uno = actual
    
    return anterior_uno

# Test
resultado = climb_stairs(4)
print(f"Formas de subir 4 escalones: {resultado}")  # 5
# Explicaci√≥n: [1+1+1+1], [1+1+2], [1+2+1], [2+1+1], [2+2]
```

------------------------------------------------------------------------

## Pattern: Binary Search

### Definici√≥n

Binary Search busca un elemento en un array ordenado dividiendo el espacio de b√∫squeda a la mitad cada iteraci√≥n.

**Complejidad:** O(log n) tiempo, O(1) espacio

**Cu√°ndo usarlo:** - Array est√° ordenado - Necesitas b√∫squeda eficiente - "Answer is in a range" problems

### Ejemplo LeetCode: Search in Rotated Sorted Array

**Problema:** Busca un n√∫mero en un array rotado ordenado.

```{python}
def search_rotated_array(nums, target):
    """
    Buscar en array rotado usando binary search.
    
    Complejidad: O(log n) tiempo
    """
    izquierda, derecha = 0, len(nums) - 1
    
    while izquierda <= derecha:
        mid = (izquierda + derecha) // 2
        
        if nums[mid] == target:
            return mid
        
        # Determinar qu√© lado est√° ordenado
        if nums[izquierda] <= nums[mid]:
            # Lado izquierdo est√° ordenado
            if nums[izquierda] <= target < nums[mid]:
                # Target est√° en lado izquierdo ordenado
                derecha = mid - 1
            else:
                izquierda = mid + 1
        else:
            # Lado derecho est√° ordenado
            if nums[mid] < target <= nums[derecha]:
                # Target est√° en lado derecho ordenado
                izquierda = mid + 1
            else:
                derecha = mid - 1
    
    return -1

# Test
resultado = search_rotated_array([4, 5, 6, 7, 0, 1, 2], 0)
print(f"√çndice: {resultado}")  # 4
```

------------------------------------------------------------------------

## Pattern: Greedy Algorithms

### Definici√≥n

Un algoritmo greedy elige la opci√≥n √≥ptima local en cada paso, esperando encontrar una soluci√≥n global √≥ptima.

**Cu√°ndo funciona:** - Tiene estructura √≥ptima - Selecci√≥n greedy lleva a soluci√≥n √≥ptima - No hay conflictos entre elecciones

**Cu√°ndo usarlo:** - Activity selection - Huffman coding - Interval scheduling - Fractional knapsack

### Ejemplo LeetCode: Jump Game

**Problema:** Dado un array donde cada elemento es el m√°ximo de saltos que puedes dar, ¬øpuedes llegar al √∫ltimo √≠ndice?

```{python}
def can_jump(nums):
    """
    Verificar si puedes llegar al final usando greedy.
    
    Complejidad: O(n) tiempo, O(1) espacio
    """
    max_reach = 0
    
    for i in range(len(nums)):
        # Si el √≠ndice actual es mayor que lo m√°ximo alcanzable, no podemos llegar
        if i > max_reach:
            return False
        
        # Actualizar el m√°ximo que podemos alcanzar
        max_reach = max(max_reach, i + nums[i])
        
        # Si ya alcanzamos el final, retornamos True
        if max_reach >= len(nums) - 1:
            return True
    
    return False

# Test
resultado = can_jump([2, 3, 1, 1, 4])
print(f"¬øPuedes llegar al final? {resultado}")  # True

resultado2 = can_jump([3, 2, 1, 0, 4])
print(f"¬øPuedes llegar al final? {resultado2}")  # False
```

------------------------------------------------------------------------

## Pattern: Recursion y Backtracking

### Definici√≥n

Recursion es una t√©cnica donde una funci√≥n se llama a s√≠ misma. Backtracking usa recursion para explorar todas las soluciones posibles y "retrocede" cuando encuentra un camino inv√°lido.

**Complejidad:** Generalmente O(branches\^depth)

**Cu√°ndo usarlo:** - Problemas combinatorios - Permutaciones/combinaciones - Maze solving - Constraint satisfaction

### Ejemplo LeetCode: Permutations

**Problema:** Genera todas las permutaciones de una lista de n√∫meros.

```{python}
def permutations(nums):
    """
    Generar todas las permutaciones usando backtracking.
    
    Complejidad: O(n! * n) tiempo
    """
    resultado = []
    
    def backtrack(camino):
        # Base case: si hemos usado todos los n√∫meros
        if len(camino) == len(nums):
            resultado.append(camino[:])
            return
        
        # Explorar todas las opciones
        for num in nums:
            if num not in camino:
                camino.append(num)
                backtrack(camino)
                camino.pop()  # Backtrack
    
    backtrack([])
    return resultado

# Test
resultado = permutations([1, 2, 3])
print(f"Permutaciones de [1,2,3]: {resultado}")
# [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]
```

------------------------------------------------------------------------

## Pattern: Divide and Conquer

### Definici√≥n

Divide and Conquer divide el problema en subproblemas independientes, los resuelve recursivamente y combina las soluciones.

**Complejidad:** Depende del problema (merge sort es O(n log n))

**Cu√°ndo usarlo:** - Merge sort / Quick sort - Binary search - Closest pair of points - Strassen matrix multiplication

### Ejemplo: Merge Sort

**Problema:** Ordena un array usando merge sort.

```{python}
def merge_sort(arr):
    """
    Ordenar usando divide and conquer.
    
    Complejidad: O(n log n) tiempo, O(n) espacio
    """
    if len(arr) <= 1:
        return arr
    
    # Dividir
    mid = len(arr) // 2
    izquierda = merge_sort(arr[:mid])
    derecha = merge_sort(arr[mid:])
    
    # Conquistar: combinar
    return merge(izquierda, derecha)

def merge(izquierda, derecha):
    """Combinar dos arrays ordenados"""
    resultado = []
    i = j = 0
    
    while i < len(izquierda) and j < len(derecha):
        if izquierda[i] <= derecha[j]:
            resultado.append(izquierda[i])
            i += 1
        else:
            resultado.append(derecha[j])
            j += 1
    
    resultado.extend(izquierda[i:])
    resultado.extend(derecha[j:])
    
    return resultado

# Test
arr = [38, 27, 43, 3, 9, 82, 10]
resultado = merge_sort(arr)
print(f"Array ordenado: {resultado}")
```

------------------------------------------------------------------------

## Problemas por Dificultad

### F√°cil (Easy)

Estos problemas te ayudan a dominar los fundamentos:

**Two Sum** - Hashtable para b√∫squeda O(1) - Conceptos: trade-off tiempo-espacio

**Valid Parentheses** - Stack para matching - Conceptos: estructura de datos apropiada

**Reverse String** - Two pointers - Conceptos: manipulaci√≥n in-place

**Binary Search** - B√∫squeda eficiente - Conceptos: dividir y conquistar

------------------------------------------------------------------------

### Medio (Medium)

Estos requieren elecci√≥n de estructura y algoritmo:

**Longest Substring Without Repeating Characters** - Sliding window + hash table - Conceptos: ventanas deslizantes

**3Sum** - Two pointers despu√©s de sort - Conceptos: combinaci√≥n de t√©cnicas

**Lowest Common Ancestor in BST** - Traversal de √°rbol - Conceptos: propiedades BST

**Number of Islands** - DFS/BFS - Conceptos: exploraci√≥n de grafos

**Word Ladder** - BFS para camino m√°s corto - Conceptos: grafos impl√≠citos

------------------------------------------------------------------------

### Dif√≠cil (Hard)

Requieren pensar creativamente:

**Median of Two Sorted Arrays** - Binary search - Conceptos: pensamiento no convencional

**Trapping Rain Water** - Two pointers o stack - Conceptos: optimizaci√≥n con estructura auxiliar

**Serialize and Deserialize Binary Tree** - Traversal y parsing - Conceptos: codificaci√≥n/decodificaci√≥n

------------------------------------------------------------------------

## Checklist de Preparaci√≥n

### Semana 1-2: Estructuras Fundamentales

-   [ ] Arrays / Listas
-   [ ] Strings
-   [ ] Hash Tables
-   [ ] Stacks
-   [ ] Queues

**Problemas a resolver:** 5-10 easy problems en cada estructura

### Semana 3-4: Estructuras Avanzadas

-   [ ] Linked Lists
-   [ ] Trees
-   [ ] Graphs
-   [ ] Heaps

**Problemas a resolver:** 5-10 medium problems en cada estructura

### Semana 5-6: Algoritmos y Patrones

-   [ ] Two Pointers
-   [ ] Sliding Window
-   [ ] DFS / BFS
-   [ ] Binary Search
-   [ ] DP (intro)

**Problemas a resolver:** 10-15 medium problems

### Semana 7-8: Patrones Avanzados

-   [ ] Dynamic Programming
-   [ ] Greedy
-   [ ] Backtracking
-   [ ] Divide and Conquer

**Problemas a resolver:** 10-15 medium/hard problems

### Semana 9-10: Mock Interviews

-   [ ] Practica timed problems (45 min)
-   [ ] Graba tu voz explicando
-   [ ] Pide feedback
-   [ ] Itera en tus debilidades

------------------------------------------------------------------------

## Recursos Recomendados

**LeetCode** - Explora por tema - Empieza con Easy - Progresa a Medium - Hard solo si tienes tiempo

**Problemas Cl√°sicos** - Two Sum - Best Time to Buy and Sell Stock - Contains Duplicate - Valid Parentheses - Merge Sorted Array

**Conceptos Transversales** - Big O Notation - Trade-offs tiempo-espacio - In-place modifications - Recursion y stack overflow

------------------------------------------------------------------------

## Durante la Entrevista: Flowchart de Decisiones

```         
‚îå‚îÄ ¬øEntiendes el problema?
‚îÇ  ‚îî‚îÄ NO ‚Üí Pregunta clarificaciones
‚îÇ  ‚îî‚îÄ S√ç ‚Üí Dibuja ejemplo
‚îÇ
‚îú‚îÄ ¬øVes un patr√≥n?
‚îÇ  ‚îî‚îÄ NO ‚Üí Brute force
‚îÇ  ‚îî‚îÄ S√ç ‚Üí Optimiza basado en patr√≥n
‚îÇ
‚îú‚îÄ ¬øPuedes optimizar m√°s?
‚îÇ  ‚îî‚îÄ S√ç ‚Üí Identifica BUD
‚îÇ  ‚îî‚îÄ NO ‚Üí Procede a code
‚îÇ
‚îú‚îÄ ¬øEntiendes tu algoritmo?
‚îÇ  ‚îî‚îÄ NO ‚Üí Revisa l√≥gica
‚îÇ  ‚îî‚îÄ S√ç ‚Üí Walk through
‚îÇ
‚îú‚îÄ ¬øEst√° correcto?
‚îÇ  ‚îî‚îÄ NO ‚Üí Ajusta algoritmo
‚îÇ  ‚îî‚îÄ S√ç ‚Üí Code
‚îÇ
‚îú‚îÄ ¬øEl c√≥digo compila?
‚îÇ  ‚îî‚îÄ NO ‚Üí Fix syntax
‚îÇ  ‚îî‚îÄ S√ç ‚Üí Test
‚îÇ
‚îî‚îÄ ¬øPas√≥ todos los casos?
   ‚îî‚îÄ NO ‚Üí Debug
   ‚îî‚îÄ S√ç ‚Üí ¬°√âxito!
```

------------------------------------------------------------------------

## Errores Comunes a Evitar

‚ùå **No preguntar por clarificaciones** - Asume cosas sobre el input - Resultado: soluci√≥n incorrecta

‚úì **En su lugar:** Pregunta por rangos, tipos, edge cases

------------------------------------------------------------------------

‚ùå **Saltar directo a c√≥digo** - No planificas el algoritmo - Resultado: c√≥digo confuso y error

‚úì **En su lugar:** Explica primero, luego c√≥digo

------------------------------------------------------------------------

‚ùå **Optimizar prematuramente** - Complejidad innecesaria - Resultado: pierdes tiempo

‚úì **En su lugar:** Brute force primero, luego optimiza

------------------------------------------------------------------------

‚ùå **No testear edge cases** - Funciona con ejemplo normal - Falla en vac√≠os/l√≠mites - Resultado: c√≥digo rechazado

‚úì **En su lugar:** Test: vac√≠o, un elemento, grande, negativo

------------------------------------------------------------------------

‚ùå **C√≥digo ilegible** - Variables confusas (x, y, z) - Sin estructura - Resultado: entrevistador no conf√≠a

‚úì **En su lugar:** C√≥digo limpio, nombres descriptivos, modular

------------------------------------------------------------------------

## Consejos Finales

### Mentalidad

-   Las entrevistas t√©cnicas son **colaborativas**, no adversariales
-   El entrevistador quiere que tengas √©xito
-   Es normal no saber la soluci√≥n perfecta al inicio
-   Muestra tu pensamiento, no el resultado

### Pr√°ctica

-   Resuelve 50-100 problemas
-   No importa cantidad, importa comprensi√≥n
-   Revisa soluciones de otros
-   Entiende por qu√© funciona, no memorices

### T√©cnicas de Relajaci√≥n

-   Respira profundo antes de hablar
-   Si te quedas en blanco, di: "D√©jame pensar un momento"
-   Es normal tomar 5-10 minutos en un problema
-   Nadie espera que resuelvas al instante

### Despu√©s de la Entrevista

-   Pide feedback espec√≠fico
-   No memorices la soluci√≥n
-   Practica variaciones del mismo problema
-   Aprende patrones, no problemas individuales

------------------------------------------------------------------------

## Conclusi√≥n

Las entrevistas t√©cnicas eval√∫an:

1.  **¬øPuedes entender un problema?** ‚Üí Escucha y pregunta
2.  **¬øPuedes planear una soluci√≥n?** ‚Üí Piensa en voz alta
3.  **¬øPuedes implementarla?** ‚Üí C√≥digo limpio
4.  **¬øPuedes validarla?** ‚Üí Tests y debugging

Domina estas habilidades y tendr√°s √©xito.

**Buena suerte en tu entrevista! üöÄ**

# Algunos recursos √∫tiles

-   [LeetCode](https://leetcode.com/)
-   [NeetCode](https://neetcode.io/)
-   [visualgo](https://visualgo.net/en)
-   [AlgoMonster](https://algo.monster/)
-   [Data Structure and Algorithm Patterns for LeetCode Interviews ‚Äì Tutorial](https://www.youtube.com/watch?v=Z_c4byLrNBU)
-   [Data Structures and Algorithms Mega Course ‚Äì Master Technical Interviews in 49 Hours](https://www.youtube.com/watch?v=xwI5OBEnsZU)
-   [Algorithms and Data Structures Tutorial - Full Course for Beginners](https://www.youtube.com/watch?v=8hly31xKli0)